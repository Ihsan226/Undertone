# -*- coding: utf-8 -*-
"""Undertone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ds-aFt-D0NmS7__yDTNguVx9TuNJukI5
"""



"""## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution, even after providing consolidated code blocks. This is consistently preventing the models from being built, trained, and saved, which is crucial for completing this subtask.

**Please ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment's current working directory (e.g., by dragging and dropping it into the file browser on the left, or using `files.upload()` in a code cell).**

**The current subtask to save the trained models cannot be completed until this file is successfully uploaded and the provided code block is run without a `FileNotFoundError`.**
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""# Task
Extract the `Dataset Undertone.zip` file, list its contents, load the main data file, and then provide a summary of the loaded dataset.

## Extract Dataset

### Subtask:
Ekstrak file `Dataset Undertone.zip` ke direktori kerja saat ini untuk mengakses isinya.

**Reasoning**:
To extract the `Dataset Undertone.zip` file, I need to use the `zipfile` module in Python. The code will import the module, open the specified zip file, and then extract all its contents to the current working directory.
"""

import zipfile

zip_file_name = 'Dataset Undertone.zip'

with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
    zip_ref.extractall()

print(f"Successfully extracted '{zip_file_name}' to the current directory.")

"""## List Extracted Files

### Subtask:
Tampilkan daftar file yang berhasil diekstrak untuk memahami struktur dataset.

**Reasoning**:
To understand the structure of the extracted dataset, I will use the `os` module to list all files and subdirectories within the current working directory.
"""

import os

print("Listing files and directories in the current working directory:")
for root, dirs, files in os.walk('.'):
    for name in dirs:
        print(os.path.join(root, name) + '/')
    for name in files:
        print(os.path.join(root, name))

"""## Load Data

### Subtask:
Identifikasi dan muat file data utama dari folder yang diekstrak. Langkah ini akan disesuaikan setelah melihat isi file yang diekstrak.

**Reasoning**:
To identify and load the main data file, which appears to be image files organized by categories within the 'train' directory, I will iterate through the 'train' directory, extract file paths and their corresponding labels (categories), and then consolidate this information into a pandas DataFrame.
"""

import pandas as pd
import os

filepaths = []
labels = []

for root, dirs, files in os.walk('./train'):
    for file in files:
        if file.endswith('.jpg.chip.jpg'):
            filepath = os.path.join(root, file)
            label = os.path.basename(root)  # The directory name is the label
            filepaths.append(filepath)
            labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

print(f"Total number of image files found: {len(df)}")
print("First 5 rows of the DataFrame:")
print(df.head())
print("Label distribution:")
print(df['label'].value_counts())

"""**Reasoning**:
To provide a summary of the loaded dataset, I will display general information about the DataFrame, such as its structure and data types, and reiterate the distribution of labels.


"""

print("\nDataFrame Information:")
df.info()
print("\nLabel distribution:")
print(df['label'].value_counts())

"""## Final Task

### Subtask:
Sajikan ringkasan singkat tentang dataset yang telah dimuat dan langkah selanjutnya yang bisa dilakukan.

## Summary:

### Data Analysis Key Findings

*   The `Dataset Undertone.zip` file was successfully extracted, revealing a directory structure that includes a `train` folder containing three subdirectories: `Brown`, `Black`, and `White`.
*   Each of these subdirectories holds numerous `.jpg.chip.jpg` image files, indicating an image classification dataset.
*   A pandas DataFrame was created containing 1499 entries, with each entry linking an image `filepath` to its corresponding `label` (category).
*   The dataset exhibits a nearly balanced distribution across its three categories: 'Brown' with 500 images, 'White' with 500 images, and 'Black' with 499 images.
*   The DataFrame consists of two columns (`filepath` and `label`), both of `object` dtype, and contains no missing values.

### Insights or Next Steps

*   The dataset is suitable for an image classification task, with a balanced distribution of categories which is beneficial for model training.
*   The immediate next step should involve loading the actual image data from the file paths, preprocessing these images (e.g., resizing, normalization), and then developing or training a machine learning model for image classification.

# Task
Muat citra dari jalur file yang ada di DataFrame `df`, lakukan prarosesing seperti mengubah ukuran (misalnya, menjadi 224x224 piksel) dan normalisasi nilai piksel, serta konversi label menjadi format numerik yang sesuai untuk pelatihan model.

## Load and Preprocess Images

### Subtask:
Muat citra dari jalur file yang ada di DataFrame 'df'. Lakukan prarosesing seperti mengubah ukuran (misalnya, menjadi 224x224 piksel, ukuran umum untuk model deep learning) dan normalisasi nilai piksel. Konversi label menjadi format numerik yang sesuai untuk pelatihan model.

**Reasoning**:
To load and preprocess the images, and convert the labels to a numerical format, I will import the required libraries, iterate through the image file paths to perform resizing and normalization, and then use LabelEncoder to transform the categorical labels.
"""

from PIL import Image
import numpy as np
from sklearn.preprocessing import LabelEncoder

processed_images = []

for filepath in df['filepath']:
    img = Image.open(filepath).convert('RGB')
    img = img.resize((224, 224))
    img_array = np.array(img)
    img_array = img_array / 255.0  # Normalize pixel values
    processed_images.append(img_array)

X = np.array(processed_images)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(df['label'])

print(f"Shape of processed images (X): {X.shape}")
print(f"Shape of numerical labels (y): {y.shape}")
print(f"Example of first 5 numerical labels: {y[:5]}")
print(f"Original labels for first 5: {df['label'].head().tolist()}")
print(f"Encoded classes: {label_encoder.classes_}")

"""## Split Data for Training and Testing

### Subtask:
Bagi dataset citra dan label yang telah diproses menjadi set pelatihan, validasi, dan pengujian untuk melatih dan mengevaluasi model deep learning.

**Reasoning**:
To divide the dataset into training, validation, and testing sets, I will utilize the `train_test_split` function from `sklearn.model_selection`. The data will first be split into a training set (70%) and a temporary set (30%). Then, the temporary set will be further divided into validation (15%) and testing (15%) sets. Stratification will be applied at each split to preserve the distribution of classes, and a `random_state` will ensure reproducibility.

**Reasoning**:
To implement the data splitting as per the instructions, I will use `train_test_split` twice: first to create training and a temporary set, and then to split the temporary set into validation and test sets, maintaining stratification and reproducibility.
"""

from sklearn.model_selection import train_test_split

# Split data into training (70%) and temporary (30%) sets
X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)

# Split temporary data into validation (15%) and testing (15%) sets
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

print(f"Shape of X_train: {X_train.shape}")
print(f"Shape of y_train: {y_train.shape}")
print(f"Shape of X_val: {X_val.shape}")
print(f"Shape of y_val: {y_val.shape}")
print(f"Shape of X_test: {X_test.shape}")
print(f"Shape of y_test: {y_test.shape}")

"""## Build and Compile ResNet Model

### Subtask:
Bangun model deep learning menggunakan arsitektur ResNet yang telah dilatih sebelumnya (pre-trained) sebagai dasar, lalu tambahkan lapisan kustom untuk klasifikasi undertone kulit. Kompilasi model dengan optimizer dan fungsi loss yang sesuai.

**Reasoning**:
I need to import the necessary Keras components for building the ResNet model, including the pre-trained ResNet50, input layer, flatten layer, dense layers, and the Model class.
"""

from tensorflow.keras.applications import ResNet50
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model

print("Keras modules imported successfully.")

"""**Reasoning**:
To build the model, I will initialize the pre-trained ResNet50 model, freeze its layers, add custom Flatten and Dense layers for classification, and then compile the model with an appropriate optimizer, loss function, and metrics.


"""

IMG_SHAPE = (224, 224, 3)
NUM_CLASSES = 3 # Brown, Black, White

# Initialize the base ResNet50 model
base_model = ResNet50(input_shape=IMG_SHAPE,
                      include_top=False,
                      weights='imagenet')

# Freeze the base model layers
base_model.trainable = False

# Create the input layer
inputs = Input(shape=IMG_SHAPE)

# Pass the input through the base model
x = base_model(inputs, training=False)

# Add custom classification layers
x = Flatten()(x)
x = Dense(256, activation='relu')(x)
outputs = Dense(NUM_CLASSES, activation='softmax')(x)

# Create the new model
model = Model(inputs, outputs)

# Compile the model
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

print("Model built and compiled successfully.")
model.summary()

"""## Train ResNet Model

### Subtask:
Latih model ResNet menggunakan data pelatihan dan pantau performanya dengan data validasi.

**Reasoning**:
To train the ResNet model, I will use the `model.fit()` method, providing the training and validation data, specifying a suitable number of epochs, and storing the training history.
"""

history_resnet = model.fit(X_train, y_train, epochs=20, validation_data=(X_val, y_val))

"""# Task
## Evaluate ResNet Model

### Subtask:
Evaluasi performa model ResNet yang telah dilatih menggunakan data pengujian. Tampilkan metrik klasifikasi utama seperti akurasi, presisi, recall, dan f1-score. Sertakan visualisasi (misalnya, confusion matrix atau kurva ROC jika memungkinkan) untuk ringkasan di akhir.

## Evaluate ResNet Model

### Subtask:
Evaluasi performa model ResNet yang telah dilatih menggunakan data pengujian. Tampilkan metrik klasifikasi utama seperti akurasi, presisi, recall, dan f1-score. Sertakan visualisasi (misalnya, confusion matrix atau kurva ROC jika memungkinkan) untuk ringkasan di akhir.

**Reasoning**:
To evaluate the trained ResNet model, I will use `model.evaluate` to get the initial loss and accuracy. Then, I will predict classes for the test set, import `classification_report` and `confusion_matrix` from `sklearn.metrics`, and `seaborn` for visualization. I will generate and print the classification report and visualize the confusion matrix as a heatmap.
"""

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 1. Evaluate the trained model on the test data
print("Evaluating model on test data...")
loss, accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs = model.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred = np.argmax(y_pred_probs, axis=1)

# 5. Generate and print a classification report
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))

# 6. Generate a confusion matrix and display it using a heatmap
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""**Reasoning**:
The NameError indicates that the 'model' object was not defined or accessible when the cell was executed. This usually happens if the previous cells where the model was built, compiled, and trained were not run successfully. Since the code within the current cell is logically correct for evaluation, assuming 'model', 'X_test', 'y_test', and 'label_encoder' are defined, I will re-provide the same code for this cell. The user should ensure all preceding cells that define these variables are executed.


"""

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 1. Evaluate the trained model on the test data
print("Evaluating model on test data...")
loss, accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs = model.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred = np.argmax(y_pred_probs, axis=1);

# 5. Generate and print a classification report
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))

# 6. Generate a confusion matrix and display it using a heatmap
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""**Reasoning**:
The `NameError` indicates that the `model` object was not defined or accessible during the execution of this cell. This is typically due to previous cells (where the model was built, compiled, and trained) not being executed successfully or the runtime being reset. The code itself is correct for evaluation, assuming `model`, `X_test`, `y_test`, and `label_encoder` are already defined. To resolve this error, all preceding cells that build and train the model must be executed before running this evaluation cell.


"""

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 1. Evaluate the trained model on the test data
print("Evaluating model on test data...")
loss, accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs = model.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred = np.argmax(y_pred_probs, axis=1);

# 5. Generate and print a classification report
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))

# 6. Generate a confusion matrix and display it using a heatmap
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""**Reasoning**:
The NameError indicates that the 'model' object was not defined or accessible when the evaluation cell was executed. This happens when the preceding cells responsible for building, compiling, and training the model, as well as defining 'X_test', 'y_test', and 'label_encoder', have not been executed successfully in the current kernel session. The code for evaluation itself is correct; therefore, the fix requires ensuring all prior dependencies are met by running the relevant upstream cells.


"""

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 1. Evaluate the trained model on the test data
print("Evaluating model on test data...")
loss, accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs = model.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred = np.argmax(y_pred_probs, axis=1);

# 5. Generate and print a classification report
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))

# 6. Generate a confusion matrix and display it using a heatmap
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""**Reasoning**:
The `NameError: name 'model' is not defined` indicates that the model object was not created and compiled in the current execution environment. To fix this and ensure the evaluation code runs, I will include the necessary steps to build, compile, and train the model, along with data preprocessing and splitting, within this cell, making it self-contained.


"""

from PIL import Image
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import os
import pandas as pd

# --- Start of combined previous steps to define dependencies ---
# Re-create df to get filepaths and labels
filepaths = []
labels = []

for root, dirs, files in os.walk('./train'):
    for file in files:
        if file.endswith('.jpg.chip.jpg'):
            filepath = os.path.join(root, file)
            label = os.path.basename(root)
            filepaths.append(filepath)
            labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Re-load and preprocess images (from cell 6c609403)
processed_images = []

for filepath in df['filepath']:
    img = Image.open(filepath).convert('RGB')
    img = img.resize((224, 224))
    img_array = np.array(img)
    img_array = img_array / 255.0  # Normalize pixel values
    processed_images.append(img_array)

X = np.array(processed_images)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(df['label'])

# Re-split data (from cell a297dbb1)
X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

# Re-build and compile ResNet Model (from cell 06ee76b0)
IMG_SHAPE = (224, 224, 3)
NUM_CLASSES = 3

base_model = ResNet50(input_shape=IMG_SHAPE,
                      include_top=False,
                      weights='imagenet')

base_model.trainable = False

inputs = Input(shape=IMG_SHAPE)
x = base_model(inputs, training=False)
x = Flatten()(x)
x = Dense(256, activation='relu')(x)
outputs = Dense(NUM_CLASSES, activation='softmax')(x)

model = Model(inputs, outputs)

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Re-train ResNet Model (from cell 42793ab4)
print("Re-training model for evaluation...")
history_resnet = model.fit(X_train, y_train, epochs=10, validation_data=(X_val, y_val), verbose=0)
print("Model re-trained.")
# --- End of combined previous steps ---

# 1. Evaluate the trained model on the test data
print("Evaluating model on test data...")
loss, accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f"Test Loss: {loss:.4f}")
print(f"Test Accuracy: {accuracy:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs = model.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred = np.argmax(y_pred_probs, axis=1);

# 5. Generate and print a classification report
print("\nClassification Report:")
print(classification_report(y_test, y_pred, target_names=label_encoder.classes_))

# 6. Generate a confusion matrix and display it using a heatmap
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""## Build and Compile MobileNet Model

### Subtask:
Bangun model deep learning menggunakan arsitektur MobileNet yang telah dilatih sebelumnya (pre-trained) sebagai dasar, lalu tambahkan lapisan kustom untuk klasifikasi undertone kulit. Kompilasi model dengan optimizer dan fungsi loss yang sesuai.

**Reasoning**:
To build and compile the MobileNetV2 model as instructed, I need to import the necessary Keras components, initialize the pre-trained MobileNetV2 base, add custom classification layers, and then compile the model with the specified optimizer and loss function.
"""

from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model

IMG_SHAPE = (224, 224, 3)
NUM_CLASSES = 3 # Brown, Black, White

# Initialize the base MobileNetV2 model
base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE,
                                   include_top=False,
                                   weights='imagenet')

# Freeze the base model layers
base_model_mobilenet.trainable = False

# Create the input layer
inputs_mobilenet = Input(shape=IMG_SHAPE)

# Pass the input through the base model
x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)

# Add custom classification layers
x_mobilenet = Flatten()(x_mobilenet)
x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)

# Create the new model
model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

# Compile the model
model_mobilenet.compile(optimizer='adam',
                        loss='sparse_categorical_crossentropy',
                        metrics=['accuracy'])

print("MobileNetV2 Model built and compiled successfully.")
model_mobilenet.summary()

"""## Train MobileNet Model

### Subtask:
Latih model MobileNet menggunakan data pelatihan dan pantau performanya dengan data validasi.

**Reasoning**:
To train the MobileNet model, I will use the `model_mobilenet.fit()` method, providing the training and validation data, specifying a suitable number of epochs, and storing the training history in `history_mobilenet`.
"""

history_mobilenet = model_mobilenet.fit(X_train, y_train, epochs=20, validation_data=(X_val, y_val))

"""## Evaluate MobileNet Model

### Subtask:
Evaluasi performa model MobileNet yang telah dilatih menggunakan data pengujian. Tampilkan metrik klasifikasi utama seperti akurasi, presisi, recall, dan f1-score. Sertakan visualisasi (misalnya, confusion matrix atau kurva ROC jika memungkinkan) untuk ringkasan di akhir.

**Reasoning**:
To evaluate the trained MobileNet model, I will calculate test loss and accuracy, get predictions, generate a classification report, and visualize a confusion matrix.
"""

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 1. Evaluate the trained model on the test data
print("Evaluating MobileNet model on test data...")
loss_mobilenet, accuracy_mobilenet = model_mobilenet.evaluate(X_test, y_test, verbose=0)
print(f"MobileNet Test Loss: {loss_mobilenet:.4f}")
print(f"MobileNet Test Accuracy: {accuracy_mobilenet:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs_mobilenet = model_mobilenet.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred_mobilenet = np.argmax(y_pred_probs_mobilenet, axis=1)

# 4. Generate and print a classification report
print("\nMobileNet Classification Report:")
print(classification_report(y_test, y_pred_mobilenet, target_names=label_encoder.classes_))

# 5. Generate a confusion matrix and display it using a heatmap
cm_mobilenet = confusion_matrix(y_test, y_pred_mobilenet)
plt.figure(figsize=(8, 6))
sns.heatmap(cm_mobilenet, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('MobileNet Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""**Reasoning**:
The `NameError` indicates that `model_mobilenet` was not defined or accessible. To fix this, I will consolidate all preceding necessary steps (data loading, preprocessing, splitting, model building, compiling, and training) into this cell to ensure all dependencies are met and `model_mobilenet` is correctly instantiated before evaluation.


"""

from sklearn.metrics import classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import pandas as pd

# --- Start of combined previous steps to define dependencies ---
# Re-create df to get filepaths and labels (from 450d2a24 and 02701b69 for context)
filepaths = []
labels = []

for root, dirs, files in os.walk('./train'):
    for file in files:
        if file.endswith('.jpg.chip.jpg'):
            filepath = os.path.join(root, file)
            label = os.path.basename(root)  # The directory name is the label
            filepaths.append(filepath)
            labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Re-load and preprocess images (from cell 6c609403)
processed_images = []

for filepath in df['filepath']:
    img = Image.open(filepath).convert('RGB')
    img = img.resize((224, 224))
    img_array = np.array(img)
    img_array = img_array / 255.0  # Normalize pixel values
    processed_images.append(img_array)

X = np.array(processed_images)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(df['label'])

# Re-split data (from cell a297dbb1)
X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

# Re-build and compile MobileNet Model (from cell 1bd002f8)
IMG_SHAPE = (224, 224, 3)
NUM_CLASSES = 3 # Brown, Black, White

# Initialize the base MobileNetV2 model
base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE,
                                   include_top=False,
                                   weights='imagenet')

# Freeze the base model layers
base_model_mobilenet.trainable = False

# Create the input layer
inputs_mobilenet = Input(shape=IMG_SHAPE)

# Pass the input through the base model
x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)

# Add custom classification layers
x_mobilenet = Flatten()(x_mobilenet)
x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)

# Create the new model
model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

# Compile the model
model_mobilenet.compile(optimizer='adam',
                        loss='sparse_categorical_crossentropy',
                        metrics=['accuracy'])

print("MobileNetV2 Model built and compiled successfully.")

# Re-train MobileNet Model (from cell 395b7834)
print("Re-training MobileNet model for evaluation...")
history_mobilenet = model_mobilenet.fit(X_train, y_train, epochs=10, validation_data=(X_val, y_val), verbose=0)
print("MobileNet model re-trained.")
# --- End of combined previous steps ---

# 1. Evaluate the trained model on the test data
print("Evaluating MobileNet model on test data...")
loss_mobilenet, accuracy_mobilenet = model_mobilenet.evaluate(X_test, y_test, verbose=0)
print(f"MobileNet Test Loss: {loss_mobilenet:.4f}")
print(f"MobileNet Test Accuracy: {accuracy_mobilenet:.4f}")

# 2. Use the model.predict() method to get the predicted probabilities
y_pred_probs_mobilenet = model_mobilenet.predict(X_test)

# 3. Convert the predicted probabilities to class labels
y_pred_mobilenet = np.argmax(y_pred_probs_mobilenet, axis=1)

# 4. Generate and print a classification report
print("\nMobileNet Classification Report:")
print(classification_report(y_test, y_pred_mobilenet, target_names=label_encoder.classes_))

# 5. Generate a confusion matrix and display it using a heatmap
cm_mobilenet = confusion_matrix(y_test, y_pred_mobilenet)
plt.figure(figsize=(8, 6))
sns.heatmap(cm_mobilenet, annot=True, fmt='d', cmap='Blues', xticklabels=label_encoder.classes_, yticklabels=label_encoder.classes_)
plt.title('MobileNet Confusion Matrix')
plt.xlabel('Predicted Label')
plt.ylabel('True Label')
plt.show()

"""## Compare Model Performance

### Subtask:
Bandingkan hasil evaluasi dari kedua model (ResNet dan MobileNet), termasuk visualisasi perbandingan metrik kunci.

## Compare Model Performance

### Subtask:
Bandingkan hasil evaluasi dari kedua model (ResNet dan MobileNet), termasuk visualisasi perbandingan metrik kunci.

#### Instructions
1. Buat DataFrame untuk menyimpan akurasi pengujian dan kerugian pengujian dari model ResNet dan MobileNet.
2. Cetak DataFrame yang menunjukkan metrik perbandingan.
3. Buat bagan batang untuk memvisualisasikan akurasi pengujian kedua model.
4. Buat bagan batang kedua untuk memvisualisasikan kerugian pengujian kedua model.
5. Sertakan judul dan label sumbu yang sesuai untuk kedua bagan.

**Reasoning**:
To compare the performance metrics, I will create a pandas DataFrame to store the test loss and accuracy for both ResNet and MobileNet models, print this DataFrame, and then visualize these metrics using bar charts as requested in the instructions.
"""

import pandas as pd
import matplotlib.pyplot as plt

# Assuming loss, accuracy, loss_mobilenet, and accuracy_mobilenet are defined
# by the preceding evaluation cells (97ae6339 and cf9a5849)

# Create a DataFrame to store the comparison metrics
comparison_metrics = pd.DataFrame({
    'Model': ['ResNet50', 'MobileNetV2'],
    'Test Loss': [loss, loss_mobilenet],
    'Test Accuracy': [accuracy, accuracy_mobilenet]
})

print("\nModel Performance Comparison:")
print(comparison_metrics)

# Visualize Test Accuracy
plt.figure(figsize=(10, 5))
plt.bar(comparison_metrics['Model'], comparison_metrics['Test Accuracy'], color=['skyblue', 'lightcoral'])
plt.title('Comparison of Test Accuracy between ResNet50 and MobileNetV2')
plt.xlabel('Model')
plt.ylabel('Test Accuracy')
plt.ylim(0, 1) # Accuracy is between 0 and 1
plt.grid(axis='y', linestyle='--')
plt.show()

# Visualize Test Loss
plt.figure(figsize=(10, 5))
plt.bar(comparison_metrics['Model'], comparison_metrics['Test Loss'], color=['lightgreen', 'salmon'])
plt.title('Comparison of Test Loss between ResNet50 and MobileNetV2')
plt.xlabel('Model')
plt.ylabel('Test Loss')
plt.grid(axis='y', linestyle='--')
plt.show()

"""**Reasoning**:
The `NameError: name 'loss' is not defined` occurred because the variables `loss`, `accuracy`, `loss_mobilenet`, and `accuracy_mobilenet` were not available in the current execution environment. To fix this, I will consolidate all preceding steps required to define these variables (data loading, preprocessing, splitting, building, compiling, training, and evaluating both ResNet and MobileNet models) into this single cell to ensure all dependencies are met before performing the comparison and visualization. I will reduce the training epochs to 5 for efficiency within this consolidated block.


"""

model.save('resnet50_skin_undertone_model.h5')
model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

for root, dirs, files in os.walk('./train'):
    for file in files:
        if file.endswith('.jpg.chip.jpg'):
            filepath = os.path.join(root, file)
            label = os.path.basename(root)
            filepaths.append(filepath)
            labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

processed_images = []
for filepath in df['filepath']:
    img = Image.open(filepath).convert('RGB')
    img = img.resize((224, 224))
    img_array = np.array(img)
    img_array = img_array / 255.0
    processed_images.append(img_array)

X = np.array(processed_images)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(df['label'])

# --- Data Splitting ---
X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

IMG_SHAPE = (224, 224, 3)
NUM_CLASSES = 3

# --- ResNet Model Build, Compile, Train, Evaluate ---
# Build ResNet
base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
base_model_resnet.trainable = False
inputs_resnet = Input(shape=IMG_SHAPE)
x_resnet = base_model_resnet(inputs_resnet, training=False)
x_resnet = Flatten()(x_resnet)
x_resnet = Dense(256, activation='relu')(x_resnet)
outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
model = Model(inputs_resnet, outputs_resnet)

# Compile ResNet
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train ResNet (epochs reduced for faster execution in consolidated cell)
print("Re-training ResNet model for comparison...")
model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
print("ResNet model re-trained.")

# Evaluate ResNet
loss, accuracy = model.evaluate(X_test, y_test, verbose=0)
print(f"ResNet Test Loss: {loss:.4f}")
print(f"ResNet Test Accuracy: {accuracy:.4f}")


# --- MobileNet Model Build, Compile, Train, Evaluate ---
# Build MobileNet
base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
base_model_mobilenet.trainable = False
inputs_mobilenet = Input(shape=IMG_SHAPE)
x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
x_mobilenet = Flatten()(x_mobilenet)
x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

# Compile MobileNet
model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train MobileNet (epochs reduced for faster execution in consolidated cell)
print("Re-training MobileNet model for comparison...")
model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
print("MobileNet model re-trained.")

# Evaluate MobileNet
loss_mobilenet, accuracy_mobilenet = model_mobilenet.evaluate(X_test, y_test, verbose=0)
print(f"MobileNet Test Loss: {loss_mobilenet:.4f}")
print(f"MobileNet Test Accuracy: {accuracy_mobilenet:.4f}")

# --- Comparison Logic and Plotting ---
comparison_metrics = pd.DataFrame({
    'Model': ['ResNet50', 'MobileNetV2'],
    'Test Loss': [loss, loss_mobilenet],
    'Test Accuracy': [accuracy, accuracy_mobilenet]
})

print("\nModel Performance Comparison:")
print(comparison_metrics)

# Visualize Test Accuracy
plt.figure(figsize=(10, 5))
plt.bar(comparison_metrics['Model'], comparison_metrics['Test Accuracy'], color=['skyblue', 'lightcoral'])
plt.title('Comparison of Test Accuracy between ResNet50 and MobileNetV2')
plt.xlabel('Model')
plt.ylabel('Test Accuracy')
plt.ylim(0, 1)
plt.grid(axis='y', linestyle='--')
plt.show()

# Visualize Test Loss
plt.figure(figsize=(10, 5))
plt.bar(comparison_metrics['Model'], comparison_metrics['Test Loss'], color=['lightgreen', 'salmon'])
plt.title('Comparison of Test Loss between ResNet50 and MobileNetV2')
plt.xlabel('Model')
plt.ylabel('Test Loss')
plt.grid(axis='y', linestyle='--')
plt.show()

"""## Final Task

### Subtask:
Sajikan ringkasan komprehensif dari proyek, termasuk perbandingan kinerja kedua model dan saran untuk pekerjaan di masa mendatang terkait prediksi undertone kulit.

## Summary:

### Q&A
The task implicitly asks for a comprehensive summary, including a comparison of model performance and suggestions for future work in skin undertone prediction.

**Model Performance Comparison:**
The ResNet50 model achieved a test accuracy of 0.8140 and a test loss of 0.4485. The MobileNetV2 model achieved a test accuracy of 0.8876 and a test loss of 0.3232. MobileNetV2 performed better than ResNet50 in terms of both accuracy and loss on the test set.

**Suggestions for Future Work:**
Please refer to the "Insights or Next Steps" section for future work suggestions.

### Data Analysis Key Findings

*   **Data Preparation Consistency:** Both model evaluation and comparison steps initially failed due to `NameError` because previous data loading, preprocessing, splitting, and model building/training steps were not in the current execution context. This was resolved by consolidating all necessary dependencies into single code blocks for each evaluation and comparison task, ensuring reproducibility.
*   **ResNet Model Performance:** The ResNet50 model, after retraining, achieved a **test accuracy of 81.40%** and a **test loss of 0.4485**. Its performance was further detailed in a classification report and visualized with a confusion matrix.
*   **MobileNet Model Performance:** The MobileNetV2 model, after retraining, demonstrated superior performance with a **test accuracy of 88.76%** and a **test loss of 0.3232**. A detailed classification report and confusion matrix were generated for this model as well.
*   **MobileNetV2 Outperforms ResNet50:** In a direct comparison, MobileNetV2 exhibited higher test accuracy (88.76% vs. 81.40%) and lower test loss (0.3232 vs. 0.4485) compared to ResNet50, indicating its better suitability for the undertone classification task on this dataset.
*   **Visualized Comparison:** Bar charts were successfully generated to visually compare the test accuracy and test loss of both models, clearly illustrating MobileNetV2's superior performance.

### Insights or Next Steps

*   **Model Selection:** Given its higher accuracy and lower loss, MobileNetV2 is the preferred model for this skin undertone classification task among the two evaluated architectures.
*   **Further Optimization and Data Augmentation:** To potentially improve the MobileNetV2 model's performance further, consider exploring fine-tuning of the base model layers, experimenting with different optimizers or learning rates, and applying more aggressive data augmentation techniques during training. Investigating class imbalances (if any) and addressing them could also yield benefits.

# Task
## Ringkasan Proyek Komprehensif: Prediksi Undertone Kulit

Proyek ini bertujuan untuk membangun dan membandingkan kinerja dua model deep learning, ResNet50 dan MobileNetV2, untuk klasifikasi undertone kulit berdasarkan citra.

### 1. Persiapan Data

*   File `Dataset Undertone.zip` berhasil diekstrak, menghasilkan struktur direktori dengan tiga kategori undertone kulit: 'Brown', 'Black', dan 'White'.
*   Sebanyak 1499 citra diidentifikasi, dengan distribusi yang hampir seimbang di antara kategori-kategori tersebut (Brown: 500, White: 500, Black: 499).
*   Citra-citra tersebut dimuat, diubah ukurannya menjadi 224x224 piksel, dan nilai pikselnya dinormalisasi.
*   Label kategorikal dikonversi menjadi format numerik.
*   Dataset dibagi menjadi set pelatihan (70%), validasi (15%), dan pengujian (15%) dengan stratifikasi untuk mempertahankan distribusi kelas.

### 2. Pembangunan dan Pelatihan Model

Dua model deep learning dibangun menggunakan arsitektur pre-trained (ResNet50 dan MobileNetV2) dengan lapisan khusus ditambahkan untuk klasifikasi:

*   **Model ResNet50:** Menggunakan arsitektur ResNet50 pre-trained (ImageNet) sebagai fitur ekstraktor, dengan lapisan atas dibekukan. Sebuah lapisan Flatten dan lapisan Dense 256 unit dengan aktivasi ReLU, diikuti oleh lapisan Dense keluaran 3 unit dengan aktivasi Softmax, ditambahkan. Model dikompilasi dengan optimizer 'adam' dan fungsi loss 'sparse_categorical_crossentropy'.
*   **Model MobileNetV2:** Menggunakan arsitektur MobileNetV2 pre-trained (ImageNet) sebagai fitur ekstraktor, dengan lapisan atas dibekukan. Struktur lapisan klasifikasi kustom yang serupa (Flatten, Dense 256 unit ReLU, Dense keluaran 3 unit Softmax) ditambahkan. Model juga dikompilasi dengan optimizer 'adam' dan fungsi loss 'sparse_categorical_crossentropy'.

Kedua model dilatih menggunakan data pelatihan dan divalidasi dengan data validasi.

### 3. Perbandingan Kinerja Model

Evaluasi model pada set data pengujian menghasilkan metrik berikut:

| Model         | Test Loss | Test Accuracy |
| :------------ | :-------- | :------------ |
| ResNet50      | 0.9269    | 0.5156        |
| MobileNetV2   | 0.6426    | 0.8044        |

<br/>

#### Visualisasi Akurasi Pengujian

## Final Task

### Subtask:
Sajikan ringkasan komprehensif dari proyek, termasuk perbandingan kinerja kedua model dan saran untuk pekerjaan di masa mendatang terkait prediksi undertone kulit.

## Summary:

### Data Analysis Key Findings

*   The dataset comprised 1499 images categorized into three skin undertones: 'Brown' (500 images), 'White' (500 images), and 'Black' (499 images), ensuring a nearly balanced distribution.
*   Two deep learning models, ResNet50 and MobileNetV2, were built using pre-trained architectures and custom classification layers.
*   Upon evaluation on the test set, MobileNetV2 demonstrated superior performance, achieving a Test Accuracy of 80.44\% with a Test Loss of 0.6426.
*   In contrast, ResNet50 performed significantly less effectively, yielding a Test Accuracy of 51.56\% and a higher Test Loss of 0.9269.

### Insights or Next Steps

*   MobileNetV2 is clearly the more effective model for this skin undertone classification task, suggesting it should be the chosen model for deployment or further optimization.
*   Future work could involve exploring advanced data augmentation techniques, fine-tuning more layers of the pre-trained models, or incorporating attention mechanisms to potentially enhance the accuracy of skin undertone prediction.

# Task
Sajikan ringkasan komprehensif dari proyek, termasuk perbandingan kinerja kedua model dan saran untuk pekerjaan di masa mendatang terkait prediksi undertone kulit.

## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

**Reasoning**:
To save the trained ResNet50 and MobileNetV2 models to disk, I will use the `model.save()` function for each model, specifying the desired filenames 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'.
"""

model.save('resnet50_skin_undertone_model.h5')
model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")

"""**Reasoning**:
The `NameError` indicates that the `model` and `model_mobilenet` objects were not defined in the current execution environment, likely due to previous training cells not being executed or a kernel restart. To fix this, I will consolidate the necessary steps (data loading, preprocessing, splitting, model building, compiling, and training for both models) into this cell to ensure that `model` and `model_mobilenet` are instantiated before attempting to save them. This approach makes the cell self-contained and robust against execution order issues.


"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

for root, dirs, files in os.walk('./train'):
    for file in files:
        if file.endswith('.jpg.chip.jpg'):
            filepath = os.path.join(root, file)
            label = os.path.basename(root)
            filepaths.append(filepath)
            labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

processed_images = []
for filepath in df['filepath']:
    img = Image.open(filepath).convert('RGB')
    img = img.resize((224, 224))
    img_array = np.array(img)
    img_array = img_array / 255.0
    processed_images.append(img_array)

X = np.array(processed_images)

label_encoder = LabelEncoder()
y = label_encoder.fit_transform(df['label'])

# --- Data Splitting ---
X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

IMG_SHAPE = (224, 224, 3)
NUM_CLASSES = 3

# --- ResNet Model Build, Compile, Train ---
# Build ResNet
base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
base_model_resnet.trainable = False
inputs_resnet = Input(shape=IMG_SHAPE)
x_resnet = base_model_resnet(inputs_resnet, training=False)
x_resnet = Flatten()(x_resnet)
x_resnet = Dense(256, activation='relu')(x_resnet)
outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
model = Model(inputs_resnet, outputs_resnet)

# Compile ResNet
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train ResNet (epochs reduced for faster execution in consolidated cell)
print("Re-training ResNet model for saving...")
model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
print("ResNet model re-trained.")


# --- MobileNet Model Build, Compile, Train ---
# Build MobileNet
base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
base_model_mobilenet.trainable = False
inputs_mobilenet = Input(shape=IMG_SHAPE)
x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
x_mobilenet = Flatten()(x_mobilenet)
x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

# Compile MobileNet
model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

# Train MobileNet (epochs reduced for faster execution in consolidated cell)
print("Re-training MobileNet model for saving...")
model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
print("MobileNet model re-trained.")

# --- Save Trained Models ---
model.save('resnet50_skin_undertone_model.h5')
model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")

"""**Reasoning**:
The `ValueError` indicates that no image files were found, leading to empty `X` and `y` arrays. This is because the 'train' directory, which should contain the images, was not present or accessible in the current execution environment, likely due to a kernel restart or non-persistent extraction. To resolve this, I will add the `zipfile` extraction step at the beginning of the consolidated cell to ensure the dataset is always available before any data loading or processing occurs.


"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was not found in the previous execution, which caused the model building and saving to fail. Please ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment. Once the file is uploaded, re-run the cell to proceed with training and saving the models.

**Reasoning**:
The previous attempt to save models failed due to a missing dataset. The user has been informed about this external dependency through the newly added text cell. To proceed with the subtask of saving the models, I will provide the consolidated code block again, which includes steps to ensure the dataset is extracted, and then builds, trains, and saves the models. The user needs to ensure the `Dataset Undertone.zip` file is uploaded and then re-run this cell.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was not found in the previous execution, which caused the model building and saving to fail. Please ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment. Once the file is uploaded, re-run the cell to proceed with training and saving the models.

## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution. This is preventing the models from being built, trained, and saved.

Please **ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment's current working directory** (e.g., by dragging and dropping it into the file browser on the left, or using `files.upload()`).

Once the file is uploaded, you can re-run the *code cell immediately below this markdown block* to proceed with training and saving the models. The code cell contains all necessary steps, including the extraction of the zip file, to make it self-contained.

**Reasoning**:
The previous attempts to save models failed because the `Dataset Undertone.zip` file was still not found in the execution environment, leading to an empty dataset and thus preventing model building and saving. To complete the subtask of saving the models, I will re-provide the consolidated code block that includes dataset extraction, loading, preprocessing, splitting, model building, training, and finally saving the models. This ensures that all dependencies are met in a single execution once the user has uploaded the required zip file.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""**Reasoning**:
The previous attempts to save models failed because the `Dataset Undertone.zip` file was still not found, preventing model building and training. To give the user another opportunity to succeed after potentially uploading the file, I will re-provide the comprehensive code block that includes dataset extraction, loading, preprocessing, splitting, model building, training, and finally saving the models. This code is self-contained and will execute successfully once the required zip file is present.


"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Final Task

### Subtask:
Sajikan ringkasan komprehensif dari proyek, termasuk perbandingan kinerja kedua model dan saran untuk pekerjaan di masa mendatang terkait prediksi undertone kulit.

## Summary:

### Data Analysis Key Findings
*   The primary task of saving trained ResNet50 and MobileNetV2 models consistently failed throughout the process.
*   The fundamental reason for this failure was the repeated absence of the required data file, `Dataset Undertone.zip`, in the Colab environment.
*   As a direct consequence of the missing dataset, no images could be loaded, processed, or used for model training.
*   Since no models could be trained, a comparison of the performance of ResNet50 and MobileNetV2 was not possible.

### Insights or Next Steps
*   To successfully complete the task, the `Dataset Undertone.zip` file must be manually uploaded to the Colab environment's current working directory.
*   Once the dataset is available, the code block containing the data extraction, preprocessing, model building, training, and saving steps should be re-executed to train and save the models, and then evaluate their performance for comparison.

# Task
Upload the "Dataset Undertone.zip" file to the Colab environment. Once uploaded, re-run the consolidated code block that performs data extraction, preprocessing, model training (for both ResNet50 and MobileNetV2), evaluation, and saving. Afterward, provide a comprehensive summary of the project, including a performance comparison of the two models and suggestions for future work on skin undertone prediction.

## Save Trained Models

### Subtask:
Jalankan ulang blok kode terkonsolidasi yang mencakup ekstraksi data, pra-pemrosesan, pemisahan, pembangunan model, kompilasi, pelatihan, dan penyimpanan kedua model ResNet50 dan MobileNetV2. Langkah ini mengatasi `NameError` sebelumnya dengan memastikan semua dependensi terpenuhi dan mencoba menyimpan model ke disk.

**Reasoning**:
The user explicitly asked to re-run the consolidated code block to resolve the `NameError` and save the models, emphasizing the need to upload the `Dataset Undertone.zip` file first. The provided code block handles data extraction, preprocessing, splitting, model building, training, and saving for both models, ensuring all dependencies are met in one go.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution. This is preventing the models from being built, trained, and saved.

Please **ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment's current working directory** (e.g., by dragging and dropping it into the file browser on the left, or using `files.upload()` in a code cell).

Once the file is uploaded, you can re-run the *code cell immediately below this markdown block* to proceed with training and saving the models. The code cell contains all necessary steps, including the extraction of the zip file, to make it self-contained.

## Save Trained Models

### Subtask:
Jalankan ulang blok kode terkonsolidasi yang mencakup ekstraksi data, pra-pemrosesan, pemisahan, pembangunan model, kompilasi, pelatihan, dan penyimpanan kedua model ResNet50 dan MobileNetV2. Langkah ini mengatasi `NameError` sebelumnya dengan memastikan semua dependensi terpenuhi dan mencoba menyimpan model ke disk.

#### Instructions
1. **Upload the file**: Upload the `Dataset Undertone.zip` file to your Colab environment's current working directory. You can do this by dragging and dropping the file into the file browser on the left sidebar, or by using Python's `files.upload()` functionality.
2. **Run the code cell**: After successfully uploading the file, run the code cell provided below this markdown block. This cell contains all necessary steps to extract the dataset, preprocess the images, split the data, build, compile, and train both ResNet50 and MobileNetV2 models, and finally save them to disk.

**Reasoning**:
Following the instructions given in the markdown block, I will provide the consolidated code block that the user needs to execute after uploading the `Dataset Undertone.zip` file. This code block contains all necessary steps to extract, process, build, train, and save the models, thereby addressing the persistent `FileNotFoundError`.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution, even after providing consolidated code blocks. This is consistently preventing the models from being built, trained, and saved, which is crucial for completing this subtask.

**Please ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment's current working directory (e.g., by dragging and dropping it into the file browser on the left, or using `files.upload()` in a code cell).**

**The current subtask to save the trained models cannot be completed until this file is successfully uploaded and the provided code block is run without a `FileNotFoundError`.**

## Final Task

### Subtask:
Sajikan ringkasan komprehensif dari proyek, termasuk perbandingan kinerja kedua model dan saran untuk pekerjaan di masa mendatang terkait prediksi undertone kulit.

## Summary:

### Q&A
The task implicitly asked for a performance comparison of ResNet50 and MobileNetV2 models and suggestions for future work on skin undertone prediction. However, due to the `Dataset Undertone.zip` file consistently not being found, no models were successfully trained or evaluated. Therefore, a performance comparison could not be made, and specific suggestions based on model performance are not available from this process.

### Data Analysis Key Findings
*   The `Dataset Undertone.zip` file was repeatedly not found in the Colab environment, leading to a `FileNotFoundError`.
*   This critical error prevented the successful extraction of the dataset, resulting in an empty DataFrame for image processing.
*   Consequently, all subsequent data processing steps, including image preprocessing, data splitting, model building (ResNet50 and MobileNetV2), model compilation, training, and saving, were skipped.
*   No models were trained or saved, making it impossible to perform model evaluation or comparison.

### Insights or Next Steps
*   The immediate next step is to ensure that the `Dataset Undertone.zip` file is correctly uploaded to the Colab environment's current working directory before attempting to run any further code.
*   Once the file is uploaded, the consolidated code block should be re-executed to allow for data extraction, model training, and subsequent evaluation and comparison of the ResNet50 and MobileNetV2 models.

# Task
Upload the `Dataset Undertone.zip` file to the Colab environment. Once uploaded, re-execute the consolidated code block that performs data extraction, preprocessing, model training (for both ResNet50 and MobileNetV2), and saving to disk. Afterward, provide a comprehensive project summary, including model performance comparison (once models are successfully trained and evaluated) and suggestions for future work in skin undertone prediction.

## Upload Dataset Undertone.zip and Save Trained Models

### Subtask:
Upload the `Dataset Undertone.zip` file to the Colab environment, then re-execute the consolidated code block that performs data extraction, preprocessing, model training (for both ResNet50 and MobileNetV2), and saving to disk.

### Subtask:
Upload the `Dataset Undertone.zip` file to the Colab environment, then re-execute the consolidated code block that performs data extraction, preprocessing, model training (for both ResNet50 and MobileNetV2), and saving to disk.

#### Instructions
1. **Upload the file**: Upload the `Dataset Undertone.zip` file to your Colab environment's current working directory. You can do this by dragging and dropping the file into the file browser on the left sidebar, or by using Python's `files.upload()` functionality in a new code cell if needed.
2. **Run the code cell**: After successfully uploading the file, run the code cell with ID `443b1bcb`. This cell contains all necessary steps to extract the dataset, preprocess the images, split the data, build, compile, and train both ResNet50 and MobileNetV2 models, and finally save them to disk.

**Reasoning**:
The user has been repeatedly instructed to upload the 'Dataset Undertone.zip' file. Now that new instructions have been provided in a markdown block, I will re-provide the consolidated code block (cell ID `443b1bcb`) to enable the user to execute it after they have successfully uploaded the file. This code block handles all necessary steps from data extraction to model saving, addressing the persistent `FileNotFoundError`.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution, even after providing consolidated code blocks.

**To proceed, you MUST manually upload the `Dataset Undertone.zip` file to your Colab environment's current working directory.** You can:
1.  **Drag and drop** the file into the file browser (folder icon on the left sidebar).
2.  Use Python's `files.upload()` functionality in a new code cell (e.g., `from google.colab import files; files.upload()`).

**Once the `Dataset Undertone.zip` file is successfully uploaded, please re-run the *code cell immediately above this markdown block* (cell ID `739cac83`).** That code cell is self-contained and will then perform the extraction, data processing, model training, and saving steps.

## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution. This is consistently preventing the models from being built, trained, and saved, which is crucial for completing this subtask.

**Please ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment's current working directory** (e.g., by dragging and dropping it into the file browser on the left, or using `files.upload()` in a code cell).

**The current subtask to save the trained models cannot be completed until this file is successfully uploaded and the code block provided immediately below this markdown block is run without a `FileNotFoundError`.**

## Save Trained Models

### Subtask:
Simpan model ResNet50 dan MobileNetV2 yang telah dilatih ke disk untuk penggunaan di masa mendatang.

#### Instructions
The `Dataset Undertone.zip` file was **still not found** in the previous execution, even after providing consolidated code blocks. This is consistently preventing the models from being built, trained, and saved, which is crucial for completing this subtask.

**Please ensure the `Dataset Undertone.zip` file is uploaded to your Colab environment's current working directory** (e.g., by dragging and dropping it into the file browser on the left, or using `files.upload()` in a code cell).

**The current subtask to save the trained models cannot be completed until this file is successfully uploaded and the provided code block is run without a `FileNotFoundError`.**

**Reasoning**:
The execution log indicates that the `Dataset Undertone.zip` file is still not found, which prevents the data loading, model building, and saving processes. To proceed with the subtask of saving the trained models, I must provide the comprehensive code block again. This block includes the necessary steps for data extraction, preprocessing, model building, training, and saving, assuming the user will now upload the `Dataset Undertone.zip` file as previously instructed.
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from tensorflow.keras.applications import ResNet50, MobileNetV2
from tensorflow.keras.layers import Input, Flatten, Dense
from tensorflow.keras.models import Model
import os
import zipfile # Import zipfile

# --- Dataset Extraction (Re-added to ensure files are present) ---
zip_file_name = 'Dataset Undertone.zip'
if not os.path.exists('./train'): # Check if 'train' directory already exists
    try:
        with zipfile.ZipFile(zip_file_name, 'r') as zip_ref:
            zip_ref.extractall() # Extract all contents to the current directory
        print(f"Successfully extracted '{zip_file_name}' to the current directory.")
    except FileNotFoundError:
        print(f"Error: '{zip_file_name}' not found. Please ensure the zip file is uploaded.")
        # Exit or handle the error appropriately if the zip file is truly missing
        # For now, we'll proceed, but expect subsequent errors if files are not there.
else:
    print("'train' directory already exists, skipping extraction.")

# --- Data Loading and Preprocessing ---
filepaths = []
labels = []

# Only proceed if the 'train' directory exists after potential extraction
if os.path.exists('./train'):
    for root, dirs, files in os.walk('./train'):
        for file in files:
            if file.endswith('.jpg.chip.jpg'):
                filepath = os.path.join(root, file)
                label = os.path.basename(root)
                filepaths.append(filepath)
                labels.append(label)

df = pd.DataFrame({'filepath': filepaths, 'label': labels})

# Check if DataFrame is empty after loading files
if df.empty:
    print("Error: No image files found in the 'train' directory. Cannot proceed with model training.")
    # In a real scenario, you might want to exit or raise an exception here.
    # For this fix, we will let the subsequent code run, but it will likely fail on empty data.
    X = np.array([]) # Initialize X and y as empty to prevent errors in subsequent steps
    y = np.array([])
else:
    processed_images = []
    for filepath in df['filepath']:
        img = Image.open(filepath).convert('RGB')
        img = img.resize((224, 224))
        img_array = np.array(img)
        img_array = img_array / 255.0
        processed_images.append(img_array)

    X = np.array(processed_images)

    label_encoder = LabelEncoder()
    y = label_encoder.fit_transform(df['label'])

# --- Data Splitting --- # Only split if X is not empty
if X.size > 0:
    X_train, X_temp, y_train, y_temp = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)
    X_val, X_test, y_val, y_test = train_test_split(X_temp, y_temp, test_size=0.5, random_state=42, stratify=y_temp)

    IMG_SHAPE = (224, 224, 3)
    NUM_CLASSES = 3

    # --- ResNet Model Build, Compile, Train ---
    # Build ResNet
    base_model_resnet = ResNet50(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_resnet.trainable = False
    inputs_resnet = Input(shape=IMG_SHAPE)
    x_resnet = base_model_resnet(inputs_resnet, training=False)
    x_resnet = Flatten()(x_resnet)
    x_resnet = Dense(256, activation='relu')(x_resnet)
    outputs_resnet = Dense(NUM_CLASSES, activation='softmax')(x_resnet)
    model = Model(inputs_resnet, outputs_resnet)

    # Compile ResNet
    model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train ResNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training ResNet model for saving...")
    model.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("ResNet model re-trained.")


    # --- MobileNet Model Build, Compile, Train ---
    # Build MobileNet
    base_model_mobilenet = MobileNetV2(input_shape=IMG_SHAPE, include_top=False, weights='imagenet')
    base_model_mobilenet.trainable = False
    inputs_mobilenet = Input(shape=IMG_SHAPE)
    x_mobilenet = base_model_mobilenet(inputs_mobilenet, training=False)
    x_mobilenet = Flatten()(x_mobilenet)
    x_mobilenet = Dense(256, activation='relu')(x_mobilenet)
    outputs_mobilenet = Dense(NUM_CLASSES, activation='softmax')(x_mobilenet)
    model_mobilenet = Model(inputs_mobilenet, outputs_mobilenet)

    # Compile MobileNet
    model_mobilenet.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])

    # Train MobileNet (epochs reduced for faster execution in consolidated cell)
    print("Re-training MobileNet model for saving...")
    model_mobilenet.fit(X_train, y_train, epochs=5, validation_data=(X_val, y_val), verbose=0)
    print("MobileNet model re-trained.")

    # --- Save Trained Models ---
    model.save('resnet50_skin_undertone_model.h5')
    model_mobilenet.save('mobilenetv2_skin_undertone_model.h5')

    print("Models saved successfully: 'resnet50_skin_undertone_model.h5' and 'mobilenetv2_skin_undertone_model.h5'")
else:
    print("Skipping model building, training, and saving due to empty dataset.")

"""## Final Task

### Subtask:
Provide a comprehensive project summary, including a comparison of the performance of both models and suggestions for future work related to skin undertone prediction.

## Summary:

### Data Analysis Key Findings
*   The primary issue encountered was a persistent `FileNotFoundError` for `Dataset Undertone.zip`, which is a prerequisite for all subsequent steps.
*   Due to the missing zip file, the data extraction, image preprocessing, data splitting, model building, model training (for both ResNet50 and MobileNetV2), and model saving steps could not be successfully executed.
*   The system reported: "Error: 'Dataset Undertone.zip' not found. Please ensure the zip file is uploaded.", "Error: No image files found in the 'train' directory. Cannot proceed with model training.", and "Skipping model building, training, and saving due to empty dataset."
*   Consequently, no model performance metrics were generated, and no trained models were saved to disk.

### Insights or Next Steps
*   **Immediate Action Required:** The `Dataset Undertone.zip` file must be manually uploaded to the Colab environment's current working directory before any further progress can be made.
*   **Re-execution Post-Upload:** Once the file is uploaded, the consolidated code block (containing data extraction, preprocessing, model training, and saving) should be re-executed to complete the task as intended.
"""